#!/usr/bin/env Rscript

#
# Created by Pierluigi Di Chiaro
# Licensed under MIT License - see LICENSE file for details
#

## This tool proceeded with the creation of a reference database


library("optparse")

option_list = list(
  make_option(c("-i", "--input"), type="character", default=NULL,
              help="provide input folder", metavar="character"),
  make_option(c("-g", "--gtf"), type="character", default=NULL,
              help="specify the GTF file to use", metavar="character"),
  make_option(c("-r", "--reference"), type="character", default=NULL,
              help="specify the reference file to use", metavar="character"),
  make_option(c("-o", "--output"), type="character", default=NULL,
              help="provide output", metavar="character")
)

optparser = OptionParser(option_list=option_list);
opt = parse_args(optparser)

if (is.null(opt$input)) {print_help(optparser)
  stop("At least one argument must be supplied (input folder)", call.=FALSE)}
if (is.null(opt$gtf)) {print_help(optparser)
  stop("At least one argument must be supplied (gtf)", call.=FALSE)}
# Reference is optional - if not provided, skip annotation step
if (is.null(opt$reference)) {
  cat("No reference file provided - skipping gene annotation step\n")
}
if (is.null(opt$output)) {print_help(optparser)
  stop("At least one argument must be supplied (output)", call.=FALSE)}


library("tidyverse")
library("tximport")
library("knitr")
library("rmarkdown")
library("GenomeInfoDb")
library("Rsamtools")
library("GenomicAlignments")
library("BiocParallel")
library("Rsubread")
library("GenomicFeatures")
library("rtracklayer")


# Parse input directories - handle both space-separated string and individual paths
BAM_DIR <- if(grepl(" ", opt$input)) {
    strsplit(opt$input, " ")[[1]]
} else {
    opt$input
}

gencode_gtf <- opt$gtf
Ref_file <- opt$reference
Output <- opt$output

cat("Processing directories:", paste(BAM_DIR, collapse=", "), "\n")
cat("GTF file:", gencode_gtf, "\n")
cat("Reference file:", ifelse(is.null(Ref_file), "None (minimal output)", Ref_file), "\n")
cat("Output file:", Output, "\n")

# Check if directories exist
for(dir in BAM_DIR) {
    if(!dir.exists(dir)) {
        stop("Directory does not exist: ", dir, call.=FALSE)
    }
}

# Check if GTF file exists
if(!file.exists(gencode_gtf)) {
    stop("GTF file does not exist: ", gencode_gtf, call.=FALSE)
}

## ---- Associate transcripts to gene IDs by tximport ---------
## Consider abundance.h5 generated by Kallisto 
cat("Associating transcripts to gene IDs\n")

# Import GTF and create tx2gene mapping
tryCatch({
    gencode_df <- as.data.frame(rtracklayer::import(gencode_gtf))
}, error = function(e) {
    stop("Error reading GTF file: ", e$message, call.=FALSE)
})

gencode_transcript <- dplyr::filter(gencode_df, type=="transcript")
gencode_gene <- dplyr::filter(gencode_df, type=="gene")

if(nrow(gencode_transcript) == 0) {
    stop("No transcripts found in GTF file", call.=FALSE)
}
if(nrow(gencode_gene) == 0) {
    stop("No genes found in GTF file", call.=FALSE)
}

tx2gene <- dplyr::select(gencode_transcript, transcript_id, gene_id)

# Create abundance file paths and check they exist
abundance_files <- file.path(BAM_DIR, 'abundance.h5')
missing_files <- abundance_files[!file.exists(abundance_files)]
if(length(missing_files) > 0) {
    stop("Missing abundance.h5 files: ", paste(missing_files, collapse=", "), call.=FALSE)
}

# Extract sample names from directory names
samples <- basename(BAM_DIR)
cat("Processing", length(samples), "samples:", paste(samples, collapse=", "), "\n")

# Run tximport
tryCatch({
    txi.kallisto <- tximport(abundance_files, type = "kallisto", tx2gene = tx2gene)
    all.reads <- as.data.frame(txi.kallisto$counts)
    names(all.reads) <- samples
    cat("Successfully imported", nrow(all.reads), "genes\n")
}, error = function(e) {
    stop("Error in tximport: ", e$message, call.=FALSE)
})

## ---- Create the reference on which we will record the Tx changes ---------
cat("Create a transcript database\n")

GENES <- as.data.frame(matrix(NA,nrow=nrow(all.reads)))
rownames(GENES) <- rownames(all.reads)
colnames(GENES) <- "gene_id"

GENES$gene_id <- as.character(rownames(GENES))
GENES$gene_ids <- gsub(GENES$gene_id, pattern="\\.[0-9]+$|\\.[0-9]+_PAR_Y", replacement="")
GENES$IDs	<- NA
GENES$tx_id <- NA
GENES$seqnames <- NA
GENES$start <- NA
GENES$end <- NA
GENES$width <- NA
GENES$strand <- NA
GENES$LOC	<- NA
GENES$type_of_gene <- NA
GENES$Symbol <- NA
GENES$HGNC <- NA
GENES$Name <- NA
GENES$Entrez.Gene.ID <- NA
GENES$cDNA_LENGTH <- NA

# More efficient gene name mapping using vectorized approach
cat("Mapping gene IDs to gene names\n")
gene_mapping <- setNames(gencode_gene$gene_name, gencode_gene$gene_id)
GENES$IDs <- gene_mapping[GENES$gene_id]
cat("Mapped", sum(!is.na(GENES$IDs)), "out of", nrow(GENES), "genes\n")

dup <- GENES$IDs[duplicated(GENES$gene_ids)]

for(ii in dup){
  w <- which(GENES$IDs==ii)
    if(length(w) == 1){
      cat(ii," not duplicated \n")
    }else{
      cat(ii," is duplicated \n")
        GENES[w[1],"IDs"] <- paste0(ii,":1")
        GENES[w[2],"IDs"] <- paste0(ii,":2")
    }
  }

## Skip annotation if no reference file provided
if (!is.null(opt$reference)) {
  ## Import the reference file - reporting symbol, Name, location etc.. of NCBI, HGNC and ENSEMBL database
  cat("Adding gene annotations from reference file\n")
  
  if(!file.exists(Ref_file)) {
    cat("Warning: Reference file not found, skipping annotation\n")
  } else {
    tryCatch({
      Anno_Txdb <- read.delim(Ref_file, stringsAsFactors=FALSE)
      
      # Clean ENSEMBL IDs for matching
      if("ENSEMBL" %in% names(Anno_Txdb)) {
        Anno_Txdb$ENSEMBL_clean <- gsub("\\;ENSG.*", "", Anno_Txdb$ENSEMBL)
        
        # Use merge for efficient matching
        cat("Performing annotation matching\n")
        gene_anno <- data.frame(gene_ids = GENES$gene_ids, stringsAsFactors=FALSE)
        
        # Try exact matching first
        matched <- merge(gene_anno, Anno_Txdb, by.x="gene_ids", by.y="ENSEMBL_clean", all.x=TRUE, sort=FALSE)
        
        # If exact matching fails, try with ENSEMBL_CHECK if it exists
        if("ENSEMBL_CHECK" %in% names(Anno_Txdb) && sum(!is.na(matched$Symbol)) < nrow(gene_anno) * 0.1) {
          cat("Trying alternative matching with ENSEMBL_CHECK\n")
          Anno_Txdb$ENSEMBL_CHECK_clean <- gsub("\\;ENSG.*", "", Anno_Txdb$ENSEMBL_CHECK)
          matched_alt <- merge(gene_anno, Anno_Txdb, by.x="gene_ids", by.y="ENSEMBL_CHECK_clean", all.x=TRUE, sort=FALSE)
          
          # Use alternative matching for genes that weren't matched before
          no_match_idx <- is.na(matched$Symbol)
          if(sum(no_match_idx) > 0) {
            matched[no_match_idx, ] <- matched_alt[no_match_idx, ]
          }
        }
        
        # Update GENES dataframe with annotations
        annotation_cols <- c("tx_id", "seqnames", "start", "end", "width", "strand", 
                           "LOC", "type_of_gene", "Symbol", "HGNC", "Name", "Entrez.Gene.ID", "cDNA_LENGTH")
        
        for(col in annotation_cols) {
          if(col %in% names(matched)) {
            GENES[[col]] <- matched[[col]]
          }
        }
        
        cat("Successfully annotated", sum(!is.na(GENES$Symbol)), "out of", nrow(GENES), "genes\n")
      } else {
        cat("Warning: No ENSEMBL column found in reference file\n")
      }
      
    }, error = function(e) {
      cat("Error reading reference file:", e$message, "\n")
      cat("Continuing without reference annotations\n")
    })
  }

  # Apply filtering only if reference file was provided and annotations exist
  if (!is.null(opt$reference) && "Symbol" %in% names(GENES)) {
    # Filter out genes without symbols (only if using reference)
    initial_count <- nrow(GENES)
    GENES <- GENES[!is.na(GENES$Symbol), ]
    cat("Filtered out", initial_count - nrow(GENES), "genes without symbols\n")

    ## Filter out genes on the chrY PAR regions
    par_genes <- grep("_PAR_Y", GENES$gene_id)
    if(length(par_genes) > 0){
      GENES <- GENES[-par_genes, ]
      cat("Filtered out", length(par_genes), "genes on chrY PAR regions\n")
    }

    ## Keep only genes where Symbol matches gene name (quality filter)
    symbol_match <- which(GENES$Symbol == gsub("\\:[0-9]+$", "", GENES$IDs))
    if(length(symbol_match) > 0){
      GENES <- GENES[symbol_match, ]
      cat("Kept", nrow(GENES), "genes with matching symbols\n")
    }
  }

} else {
  ## No reference provided - keep only gene_id (minimal output)
  cat("Creating minimal gene matrix with gene_id only\n")
  
  # Keep only essential gene_id column - no additional annotation columns
  # GENES dataframe already has gene_id column, just keep it as is
}


## ---- Create final gene expression matrix ---------
cat("Creating final gene expression matrix\n")

# Ensure GENES and all.reads have matching gene sets
common_genes <- intersect(rownames(all.reads), rownames(GENES))
if(length(common_genes) == 0) {
  stop("No common genes found between expression data and annotation", call.=FALSE)
}

cat("Found", length(common_genes), "common genes between expression and annotation\n")

# Subset both datasets to common genes
GENES <- GENES[common_genes, ]
reads <- all.reads[common_genes, samples]

# Check dimensions match
if(nrow(GENES) != nrow(reads)) {
  stop("Dimension mismatch between annotation and expression data", call.=FALSE)
}

if (!is.null(opt$reference) && "Symbol" %in% names(GENES) && sum(!is.na(GENES$Symbol)) > 0) {
  ## With reference: create full annotated matrix
  cat("Creating annotated gene expression matrix with", nrow(GENES), "genes\n")
  RES_DAT_ALL <- cbind(GENES, reads)
  
  # Only sort by tx_id if it exists and is numeric
  if("tx_id" %in% names(RES_DAT_ALL) && any(!is.na(RES_DAT_ALL$tx_id))) {
    numeric_tx <- suppressWarnings(as.numeric(RES_DAT_ALL$tx_id))
    if(any(!is.na(numeric_tx))) {
      RES_DAT_ALL <- RES_DAT_ALL[order(numeric_tx, na.last=TRUE), ]
    }
  }
  
  # Remove tx_id from final output
  if("tx_id" %in% names(RES_DAT_ALL)) {
    RES_DAT_ALL$tx_id <- NULL
  }
  
  rownames(RES_DAT_ALL) <- NULL
} else {
  ## Without reference: minimal matrix with gene_id only
  cat("Creating minimal gene expression matrix with", nrow(GENES), "genes\n")
  RES_DAT_ALL <- data.frame(gene_id = rownames(GENES), reads, stringsAsFactors = FALSE)
  rownames(RES_DAT_ALL) <- NULL
}

# Write output
cat("Writing output to:", Output, "\n")
write.table(RES_DAT_ALL, file=Output, sep="\t", col.names=NA, row.names=FALSE, quote=FALSE)
cat("Successfully created expression matrix with", nrow(RES_DAT_ALL), "genes and", ncol(RES_DAT_ALL)-1, "samples\n")

